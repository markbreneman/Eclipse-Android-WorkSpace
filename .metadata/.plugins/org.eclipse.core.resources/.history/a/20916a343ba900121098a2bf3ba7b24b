package com.example.thesecondnatureproject;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
//import java.util.prefs.Preferences;
import java.net.URL;
import java.util.Date;


import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.client.DefaultHttpClient;


import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Configuration;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.hardware.Camera;
import android.hardware.Camera.PreviewCallback;
import android.location.Location;
import android.location.LocationManager;
import android.media.ExifInterface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.provider.MediaStore;
import android.provider.MediaStore.Images.Media;
import android.provider.Settings.Secure;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.regions.Region;
import com.amazonaws.regions.Regions;
import com.amazonaws.services.s3.AmazonS3Client;
import com.amazonaws.services.s3.model.GeneratePresignedUrlRequest;
import com.amazonaws.services.s3.model.PutObjectRequest;
import com.amazonaws.services.s3.model.ResponseHeaderOverrides;

import com.example.thesecondnatureproject.R;
import com.example.thesecondnatureproject.Constants;
import com.example.thesecondnatureproject.Preferences;


public class MainActivity extends Activity implements OnClickListener {
	
	
	private static final String TAG = "MotionDetectionActivity";
	
	SurfaceView cameraView;
	SurfaceHolder surfaceHolder;
	Camera camera;
	boolean inPreview = false;
	private static volatile AtomicBoolean processing = new AtomicBoolean(false);
	private static long mReferenceTime = 0;
	private static IMotionDetection detector = null;
	
	Button startStopButton;
	TextView countdownTextView;
	
	boolean motionDetectionSwitch = false;
	public static boolean tookPhoto = false;
	public static final int configuration= 0;
	
	private AmazonS3Client s3Client = new AmazonS3Client(
			new BasicAWSCredentials(Constants.ACCESS_KEY_ID,
					Constants.SECRET_KEY));
	
	public static ArrayList<Photoobject> listofPhotoobjects = new ArrayList<Photoobject>();
	
	TelephonyManager tm;
	public static String mydeviceId;
	public static String lat;
	public static String lon;
	
	//IMAGE UPLOADING ATTRIBUTES
	long fileLength = 0;
	TextView progressText;
	
	
	//WHEN THE APP STARTS
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
        TelephonyManager tm = (TelephonyManager)MainActivity.this.getSystemService(Context.TELEPHONY_SERVICE);

	
	    cameraView = (SurfaceView) this.findViewById(R.id.CameraView);
		surfaceHolder = cameraView.getHolder();
		surfaceHolder.addCallback(surfaceCallback);
		surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
		
		//OPEN UP PREFERENCE AND DETERMINE WHICH DETECTOR TYPE TO USE
		if (Preferences.USE_RGB){ 
	            detector = new RGBMotionDetection();
	        } else if (Preferences.USE_LUMA) {
	            detector = new LumaMotionDetection();
	        } else {
	            // Using State based (aggregate map)
	            detector = new AggregateLumaMotionDetection();
	        }
		
		
		//SETUP COUNTDOWNTEXT
		countdownTextView = (TextView) findViewById(R.id.CountDownTextView);
		//SETUP STARTBUTTON
		startStopButton = (Button) findViewById(R.id.startStopButton);
		startStopButton.setOnClickListener(this);
		
		//SETUP DATA PROPERTIES FOR UDID
		((TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();
        final String DeviceId, SerialNum, androidId;
         DeviceId = tm.getDeviceId();
         mydeviceId = DeviceId;
         Log.v("My Id", "Android DeviceId is: " +DeviceId); 
        
       //SETUP UPLOAD DIALOG BOX
         progressText = (TextView) findViewById(R.id.progressText);
         
	}
	
	//DECLARE FUNCTION FOR WHAT HAPPENS ON CONFIGURATION CHANGES ex. screen rotation.
	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		super.onConfigurationChanged(newConfig);
	}
	
	//WHEN THE USER LEAVES THE SPECIFIED ACTIVITY
	@Override
	public void onPause() {
        super.onPause();

        camera.setPreviewCallback(null);
        if (inPreview) camera.stopPreview();
        inPreview = false;
        camera.release();
        camera = null;
        
      //UPDATE THE GALLERY - mb
        this.sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse("file://"+ Environment.getExternalStorageDirectory())));
	}
	
	//AFTER THE APP IS LAUNCHED AND STARTED AND 
	//WHEN COMING BACK FROM PAUSED
	@Override
	public void onResume() {
	    super.onResume();
	    camera = Camera.open();
	}

	//GET THE BEST PREVIEW SIZE FOR THE PHONE
	private Camera.Size getBestPreviewSize(int width, int height, Camera.Parameters parameters) {
        Camera.Size result = null;
        //For the Phone's camera Params get the supported preview sizes
        //iterate through sizes to get largest supported 
        for (Camera.Size size : parameters.getSupportedPreviewSizes()) {
            if (size.width <= width && size.height <= height) {
                if (result == null) {
                    result = size;
                } else {
                    int resultArea = result.width * result.height;
                    int newArea = size.width * size.height;

                    if (newArea > resultArea) result = size;
                }
            }
        }

        return result;
    }

	//CALLBACK INTERFACE USED TO DELIVER COPIES OF PREVIEW FRAMES 
	//AS THEY ARE DISPLAYED
	private PreviewCallback previewCallback = new PreviewCallback() {

	    @Override
	    public void onPreviewFrame(byte[] data, Camera cam) {
	        if (data == null) return;
	        Camera.Size size = cam.getParameters().getPreviewSize();
	        if (size == null) return;
	        
	        //THIS IS A CHECK TO MAKE SURE THE PHONE IS NOT IN MOTION
	        //IT PREVENTS THE PHONE FROM CAPTURING DATA WHEN IN MOTION
	        //IF THE PHONE IS NOT IN MOTION START A NEW DETECTION THREAD
	        if (!GlobalData.isPhoneInMotion() & motionDetectionSwitch==true) {
	            DetectionThread thread = new DetectionThread(data, size.width, size.height);
	            thread.start();
	        }
	     
	    }
	};

	//CALLBACK INTERFACE TO RECEIVE INFORMATION ABOUT 
	//CHANGES TO THE SURFACE HOLDER 
	
	private SurfaceHolder.Callback surfaceCallback = new SurfaceHolder.Callback() {

       @Override
       public void surfaceCreated(SurfaceHolder holder) {
           try {
        	   //SET CAMERA TO DISPLAY SURFACE HOLDER
               camera.setPreviewDisplay(surfaceHolder);
               //CALL PREVIEW CALL BACK
               camera.setPreviewCallback(previewCallback);  
               
           } catch (Throwable t) {
               Log.e("PreviewDemo-surfaceCallback", "Exception in setPreviewDisplay()", t);
           }
       }

       @Override
       public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
           Camera.Parameters parameters = camera.getParameters();
           Camera.Size size = getBestPreviewSize(width, height, parameters);
           try{
           if(MainActivity.this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE){
				
				parameters.set("orientation", "portrait");	
				camera.setDisplayOrientation(90);
			}
			else{
				parameters.set("orientation", "landscape");
				camera.setDisplayOrientation(0);
			}
         
           if (size != null) {
               parameters.setPreviewSize(size.width, size.height);
               Log.d(TAG, "Using width=" + size.width + " height=" + size.height);
           camera.setParameters(parameters);
           camera.startPreview();
           inPreview = true;}
           }
           finally{
          			
          		}        	   
           }
  
       @Override
       public void surfaceDestroyed(SurfaceHolder holder) {
       	//NOTHING NEED TO HAPPEN HERE YET.
       }
   };
   
   //CLASS FOR DETECTION
    class DetectionThread extends Thread {

       private byte[] data;
       private int width;
       private int height;

       public DetectionThread(byte[] data, int width, int height) {
           this.data = data;
           this.width = width;
           this.height = height;
       }
       
       //START THE IMAGE PROCESSING ROUTINE
       @Override
       public void run() {
    	   
    	   //WHAT IS THIS ABOUT ...?
           if (!processing.compareAndSet(false, true)) return;

//            Log.d(TAG, "BEGIN PROCESSING...");
            
           try {
               // PREVIOUS FRAME
               int[] pre = null;
               if (Preferences.SAVE_PREVIOUS) pre = detector.getPrevious();

               int[] img = null;
               // DETERMIN HOW TO HANDLE DATA:
               // RGB OR LUMA BASED OFF PREFERENCE.
               
               if (Preferences.USE_RGB) {
                   img = ImageProcessing.decodeYUV420SPtoRGB(data, width, height);
               } else {
                   img = ImageProcessing.decodeYUV420SPtoLuma(data, width, height);
               }
      
               int[] org = null;
               
               
               if (Preferences.SAVE_ORIGINAL && img != null) org = img.clone();
               //CLONE THE IMAGE & NAME IT ORG
               
               //IF THERE IS AN IMAGE AND DETECTION IS CALLED CHECK TIME BETWEEN
               if (img != null && detector.detect(img, width, height)) {
                   // The delay is necessary to avoid taking a picture while in
                   // the middle of taking another. This problem can causes some
                   // phones to reboot.
                   long now = System.currentTimeMillis();
                   if (now > (mReferenceTime + Preferences.PICTURE_DELAY)) {
                       mReferenceTime = now;//Last picture time.

                       Bitmap previous = null;
                       if (Preferences.SAVE_PREVIOUS && pre != null) {
                           if (Preferences.USE_RGB) previous = ImageProcessing.rgbToBitmap(pre, width, height);
                           else previous = ImageProcessing.lumaToGreyscale(pre, width, height);
                       }

                       Bitmap original = null;
                       if (Preferences.SAVE_ORIGINAL && org != null) {
                           if (Preferences.USE_RGB) original = ImageProcessing.rgbToBitmap(org, width, height);
                           else original = ImageProcessing.lumaToGreyscale(org, width, height);
                       }

                       Bitmap bitmap = null;
                       if (Preferences.SAVE_CHANGES && img != null) {
                           if (Preferences.USE_RGB) bitmap = ImageProcessing.rgbToBitmap(img, width, height);
                           else bitmap = ImageProcessing.lumaToGreyscale(img, width, height);
                       }

                       Log.i(TAG, "Saving.. previous=" + previous + " original=" + original + " bitmap=" + bitmap);
                       
                      
                       Looper.prepare();
                       //CALL THE SAVE PHOTO FUNCTION
                       new SavePhotoTask().execute(previous, original, bitmap);
                       
                   } else {
                       Log.i(TAG, "Not taking picture because not enough time has passed since the creation of the Surface");
                   }
               }
           } catch (Exception e) {
               e.printStackTrace();
           } finally {
           processing.set(false);
           }
//           Log.d(TAG, "ENDED PROCESSING...");
           processing.set(false);      
       }
   };	

   
    class SavePhotoTask extends AsyncTask<Bitmap, Integer, Integer> {
      
       @Override
       protected Integer doInBackground(Bitmap... data) {
    	   
           for (int i = 0; i < data.length; i++) {
               Bitmap bitmap = data[i];
               ///THIS IS WHERE THE FILE NAME IS SET
               String name = String.valueOf(mydeviceId+"_"+System.currentTimeMillis());
               if (bitmap != null) save(name, bitmap);
               
           }
           return 1;      
       }
       
  
       private void save(String name, Bitmap bitmap) {
           File photo = new File(Environment.getExternalStorageDirectory(), name + ".jpg");
           String selectedImageFilePath=photo.getAbsolutePath();           
           Uri selectedImageUri = Uri.fromFile(photo);
           String theDevice=mydeviceId;
           Long timeTaken=System.currentTimeMillis();
           fileLength=photo.length();
           
           Photoobject currentPhoto=new Photoobject();
           currentPhoto.create(name, timeTaken, theDevice, photo, fileLength);
           
                    
           listofPhotoobjects.add(currentPhoto);
           
           
           if (photo.exists()) photo.delete();
           
           try {
        	
               FileOutputStream fos = new FileOutputStream(photo.getPath());
               bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
               fos.close();
             //THIS IS WHERE THE UDID GETS ADDED TO BITMAP -EXIF DATA TAGS
               ExifInterface ei = new ExifInterface(photo.getPath());
               ei.setAttribute(ExifInterface.TAG_MAKE, mydeviceId);
               ei.saveAttributes();
              
               Log.v("Saving", "SavedPhoto");   
               tookPhoto=!tookPhoto;
               
               
           } catch (java.io.IOException e) {
               Log.e("PictureDemo", "Exception in photoCallback", e);
           }
       }
       
       protected void onPostExecute() {
        	 //Toast Took Photo
  	         if(tookPhoto){
  	         Toast photoSave = Toast.makeText(MainActivity.this, "Saved Photo", Toast.LENGTH_SHORT);
  	 		 photoSave.show();
  	 		   }
           }
   }
   
    //SETUP A "PHOTO-OBJECT"
    class Photoobject{
    	String fileNameOfPhoto;
    	Long timePhotoTaken;
    	String deviceTakenOn;
    	File theFile;
    	Long theFileSize;
    	
    	public void create(String photoName, Long photoTimeTaken, String photoDevice, File photoFile, Long photoSize){
    		fileNameOfPhoto= photoName;
    		timePhotoTaken= photoTimeTaken;
    		deviceTakenOn= photoDevice;
    		theFile= photoFile;
    		theFileSize=photoSize;
//    		Log.v("CreatePhotoObject", "Created PhotoObject");
    	}
    	
    }
    
    //START STOP MOTION DETECTION
	public void onClick(View v) {

		if(!motionDetectionSwitch){
			startStopButton.setText("Stop Motion Detection");
			motionDetectionSwitch =true;
		} else {
			startStopButton.setText("Start Motion Detection");
			motionDetectionSwitch =false;
			this.sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.parse("file://"+ Environment.getExternalStorageDirectory())));
		
			Log.v("PhotoObjectList",String.valueOf(listofPhotoobjects.size()));
			
	  }
	}
	
	//SWITCHING TO SETTINGS
	public void settingsClicked(View v){
		Log.v("SettingsClicked","SettingsClicked");	
		Intent i = new Intent(this,ConfigurationActivity.class);
//		i.putExtra(MainActivity.PASSING_DATA, "Here is the data I am passing");
		startActivityForResult(i, configuration);	
	}
	
	public void uploadClicked(View v){
		Log.v("uploadClicked","upload Clicked");	
		new SecondNatureUpload().execute(listofPhotoobjects);
				
	}

	class SecondNatureUpload extends AsyncTask<ArrayList<Photoobject>, String, Void> implements
	
	ProgressListener {

		
		@Override
		protected Void doInBackground(ArrayList<Photoobject>... photoObjectList) {
			
		    ArrayList<Photoobject> passedinlistOfPhotoObject= photoObjectList[0];
		    
		    for (int i = 0; i < passedinlistOfPhotoObject.size(); i++) {
		    	
		    	String fileName= passedinlistOfPhotoObject.get(i).fileNameOfPhoto;
		    	String	timeTaken=passedinlistOfPhotoObject.get(i).timePhotoTaken.toString();
		    	String location= passedinlistOfPhotoObject.get(i).deviceTakenOn;
		    	File photoFile= passedinlistOfPhotoObject.get(i).theFile;
		    	

				HttpClient httpclient = new DefaultHttpClient();
				HttpPost httppost = new HttpPost("http://www.thesecondnatureproject.com/upload");
			
				ProgressMultipartEntity multipartentity = new ProgressMultipartEntity(this);
		
				 try {
					 	
					 	multipartentity.addPart("fileName", new StringBody(fileName));
						multipartentity.addPart("timeTaken", new StringBody(timeTaken));
						multipartentity.addPart("UUID", new StringBody(location));
						multipartentity.addPart("fileupload", new FileBody(photoFile));
						
						Log.v("TryingtoUpload","Trying to Upload");	
						
				
						httppost.setEntity(multipartentity);
						HttpResponse httpresponse = httpclient.execute(httppost);
				
						HttpEntity responseentity = httpresponse.getEntity();
						if (responseentity != null) {
				
							InputStream inputstream = responseentity.getContent();
							//This is where the return message goes.
							inputstream.close();
				
						}
					} catch (ClientProtocolException e) {
						e.printStackTrace();
					} catch (IOException e) {
						e.printStackTrace();
					}
				 return null;		
				} //END FOR LOOP
		    return null;
		}
		
		
		protected void onProgressUpdate(String... textToDisplay) {
			progressText.setText(textToDisplay[0]);
		}
		
		protected void onPostExecute(Void result) {
			listofPhotoobjects.clear();
		}
		
		public void transferred(long num) {
			double percent = (double) num / (double) fileLength;
			int percentInt = (int) (percent * 100);
		
			publishProgress("" + percentInt + "% Transferred");
		}
		
		
	} //Ends Upload Task

	class ProgressMultipartEntity extends MultipartEntity {
		ProgressListener progressListener;

		public ProgressMultipartEntity(ProgressListener pListener) {
			super();
			this.progressListener = pListener;
		}

		@Override
		public void writeTo(OutputStream outstream) throws IOException {
			super.writeTo(new ProgressOutputStream(outstream,
					this.progressListener));
		}
	}
	interface ProgressListener {
		void transferred(long num);
	}

	static class ProgressOutputStream extends FilterOutputStream {

		ProgressListener listener;
		int transferred;

		public ProgressOutputStream(final OutputStream out,
				ProgressListener listener) {
			super(out);
			this.listener = listener;
			this.transferred = 0;
		}

		public void write(byte[] b, int off, int len) throws IOException {
			out.write(b, off, len);
			this.transferred += len;
			this.listener.transferred(this.transferred);
		}

		public void write(int b) throws IOException {
			out.write(b);
			this.transferred++;
			this.listener.transferred(this.transferred);
		}
	}
}

